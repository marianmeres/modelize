# @marianmeres/modelize - LLM Context Document

## Package Summary

Name: @marianmeres/modelize
Version: 2.0.1
License: MIT
Author: Marian Meres
Repository: https://github.com/marianmeres/modelize

A lightweight utility that wraps any JavaScript/TypeScript object with a Proxy to provide:
- Change tracking (dirty state detection)
- Validation (JSON Schema via AJV and/or custom validators)
- Reset capabilities (clear dirty state or restore initial values)
- Svelte-compatible reactivity (Svelte store contract support)

## File Structure

```
src/
├── mod.ts           # Entry point, re-exports from modelize.ts
└── modelize.ts      # Main implementation (~690 lines)
tests/
└── modelize.test.ts # Test suite (514 lines, comprehensive coverage)
scripts/
└── build-npm.ts     # Build script for npm distribution
```

## Core API

### Main Function

```typescript
function modelize<T extends object>(
    source: T,
    options?: ModelizeOptions<T>
): Modelized<T>
```

### Options Interface

```typescript
interface ModelizeOptions<T extends object> {
    schema?: JSONSchema;                    // JSON Schema for AJV validation
    validate?: (model: T) => true | string; // Custom validator (return true or error message)
    strict?: boolean;                       // Prevent property addition/deletion (default: true)
}
```

### Added Properties (read-only)

- `__dirty: Set<keyof T>` - Set of modified property keys
- `__isDirty: boolean` - true if any property modified
- `__isValid: boolean` - true if validation passes (triggers lazy validation)
- `__errors: ValidationError[]` - Last validation errors
- `__source: T` - Reference to original unwrapped object
- `__initial: T` - Deep clone of initial values

### Added Methods

- `__validate(): true` - Throws ModelizeValidationError if invalid
- `__reset(): void` - Clears dirty state (keeps current values)
- `__resetToInitial(): void` - Restores initial values and clears dirty
- `__hydrate(data: Partial<T>, options?: { resetDirty?: boolean }): void` - Bulk update
- `subscribe(callback: (model: Modelized<T>) => void): () => void` - Svelte store contract

### Type Exports

```typescript
export type { JSONSchema, Modelized, ModelizeOptions, ValidationError }
export { ModelizeValidationError }
```

## Dependencies

- ajv@^8.17.1 (npm) - JSON Schema validation
- @marianmeres/pubsub@^2.4.1 (jsr) - Change notification pub/sub

## Reserved Property Names

Cannot be used in source objects:
`__dirty`, `__isDirty`, `__isValid`, `__source`, `__initial`, `__errors`,
`__validate`, `__reset`, `__resetToInitial`, `__hydrate`, `subscribe`

## Important Behaviors

### Shallow Tracking
Only direct property assignments trigger dirty state. Nested object mutations
(e.g., `model.nested.prop = x`) do NOT mark the parent property as dirty.
To track nested changes, replace the entire nested object.

### Lazy Validation
Validation only runs when accessing `__isValid` or calling `__validate()`.
Not triggered automatically on property changes.

### Strict Mode (default: true)
- Prevents adding new properties to the model
- Prevents deleting existing properties
- Set `strict: false` to allow dynamic properties

### Svelte Integration
The `subscribe` method (without `__` prefix) implements the Svelte store contract:
- Callback is called immediately with current value
- Callback is called on every change
- Returns unsubscribe function
- Works with Svelte's `$` auto-subscription syntax

## Build & Test Commands

```bash
deno test              # Run tests
deno task npm:build    # Build npm distribution
deno task npm:publish  # Build and publish to npm
```

## Validation Error Format

```typescript
interface ValidationError {
    path: string;      // JSON Pointer (e.g., "/age", "/" for root)
    message: string;   // Human-readable error description
}

class ModelizeValidationError extends Error {
    errors: ValidationError[];
}
```

## Usage Patterns

### Basic Dirty Tracking
```typescript
const user = modelize({ name: "John", age: 30 });
user.name = "Jane";
user.__isDirty;        // true
user.__dirty;          // Set { 'name' }
user.__reset();        // Clears dirty, keeps "Jane"
user.__resetToInitial(); // Restores "John"
```

### JSON Schema Validation
```typescript
const user = modelize({ age: 25 }, {
    schema: {
        type: "object",
        properties: { age: { type: "number", minimum: 0 } }
    }
});
user.age = -5;
user.__isValid;  // false
user.__errors;   // [{ path: '/age', message: 'must be >= 0' }]
```

### Custom Validator
```typescript
const form = modelize({ password: "", confirm: "" }, {
    validate: (m) => m.password === m.confirm ? true : "Passwords must match"
});
```

### Bulk Updates
```typescript
model.__hydrate({ name: "Jane", age: 25 }); // Single notification
model.__hydrate({ name: "Bob" }, { resetDirty: true }); // Also clears dirty
```

### Svelte Store Usage
```svelte
<script>
const user = modelize({ name: "John" });
</script>
<input bind:value={$user.name} />
{#if $user.__isDirty}<button on:click={() => $user.__reset()}>Reset</button>{/if}
```

## Internal Architecture

1. **Proxy Handler**: Intercepts get/set/deleteProperty operations
2. **Dirty Set**: Tracks modified property keys
3. **Initial Clone**: Deep clone stored at creation for reset
4. **AJV Instance**: Lazy-initialized, validators cached
5. **PubSub**: @marianmeres/pubsub for change notifications

## Edge Cases

- Empty objects work fine
- Array mutations (push, pop, etc.) don't trigger dirty; replace array to trigger
- JSON.stringify and Object.keys work correctly on modelized objects
- Class instances can be modelized (methods preserved)
