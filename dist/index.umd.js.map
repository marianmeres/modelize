{"version":3,"file":"index.umd.js","sources":["../src/object-utils.ts","../src/modelize.ts","../src/create-pub-sub.ts"],"sourcesContent":["export const isObject = (o) => Object.prototype.toString.call(o) === '[object Object]';\n\n//\nexport const isPlainObject = (o) => {\n\tlet ctor, prot;\n\n\tif (isObject(o) === false) return false;\n\n\t// If has modified constructor\n\tctor = o.constructor;\n\tif (ctor === undefined) return true;\n\n\t// If has modified prototype\n\tprot = ctor.prototype;\n\tif (isObject(prot) === false) return false;\n\n\t// If constructor does not have an Object-specific method\n\tif (prot.hasOwnProperty('isPrototypeOf') === false) return false;\n\n\t// Most likely a plain Object\n\treturn true;\n};\n\n//\nexport const isEmptyObject = (o) =>\n\to && Object.keys(o).length === 0 && o.constructor === Object;\n\n//\nexport const getPrototypeChain = (o) => {\n\tif (o === null) return null;\n\tif (typeof o !== 'object') return null;\n\n\tlet proto = Object.getPrototypeOf(o);\n\tconst out = [];\n\n\twhile (!isPlainObject(proto)) {\n\t\tout.push(proto);\n\t\tproto = Object.getPrototypeOf(proto);\n\t}\n\n\treturn out.length ? out : null;\n};\n\n//\nexport const hasSetterFor = (o, prop) =>\n\t(getPrototypeChain(o) || []).some((proto) => {\n\t\tlet desc = Object.getOwnPropertyDescriptor(proto, prop);\n\t\treturn desc && !!desc.set;\n\t});\n\n//\nexport const hasGetterFor = (o, prop) =>\n\t(getPrototypeChain(o) || []).some((proto) => {\n\t\tlet desc = Object.getOwnPropertyDescriptor(proto, prop);\n\t\treturn desc && !!desc.get;\n\t});\n","import { isObject } from './object-utils.js';\nimport { createPubSub } from './create-pub-sub.js';\nimport Ajv from 'ajv';\n\nconst clog = console.log;\n\ntype Validator<T> = (model: T, schema, assert?: boolean) => boolean;\n\nexport interface ModelizeConfig<T> {\n\t// whether to allow setting unknown properties (this is checked regardless of schema,\n\t// just using the same naming convention)\n\tadditionalProperties: boolean;\n\t// tsconfig.json strictNullChecks must be enabled to use JSONSchemaType\n\t// schema: JSONSchemaType<T>;\n\tschema: any;\n\tvalidator: Validator<T>;\n}\n\n// prefixing with \"__\" to minimize potential name conflicts with <T>\ninterface ModelizedMethods<T> {\n\ttoJSON: () => Record<keyof T, any>;\n\t__hydrate: (data?: Partial<Record<keyof T, any>>, forceClean?: boolean) => any;\n\t__isDirty: () => (keyof T)[];\n\t__setClean: () => Modelized<T>;\n\t__setDirty: (keys: (keyof T)[]) => Modelized<T>;\n\t__getDirty: () => Partial<Record<keyof T, any>>;\n\t__validate: (assert?: boolean) => boolean;\n\t__setSchema: (schema: any) => Modelized<T>;\n\t__getSchema: () => any;\n\t__setValidator: (validator: Validator<T>) => Modelized<T>;\n\t__getValidator: () => Validator<T>;\n\t__setAllowAdditionalProps: (flag: boolean) => Modelized<T>;\n\t__onChange: (\n\t\tcb: (model: T, changed: { property: keyof T; old: any; new: any }) => any\n\t) => Function;\n\t// for data hackings... subject of change\n\t__pauseValidate: () => Modelized<T>;\n\t__resumeValidate: () => Modelized<T>;\n}\n\nexport type Modelized<T> = T & ModelizedMethods<T>;\n\nexport class ModelizeUnableToValidate extends Error {}\nexport class ModelizeValidationError extends Error {}\n\nconst _validateErrorsToString = (errors) =>\n\t(errors || [])\n\t\t.reduce((memo, e) => {\n\t\t\tmemo.push(`${e.schemaPath} ${e.message} ${JSON.stringify(e.params)}`);\n\t\t\treturn memo;\n\t\t}, [])\n\t\t.join(', ');\n\n// @ts-ignore\nconst ajv = new Ajv({ strict: false, validateFormats: false });\n\nexport function modelize<T extends object>(\n\tmodel: T,\n\tdata: Partial<Record<keyof T, any>> = {},\n\tconfig: Partial<ModelizeConfig<T>> = {}\n): Modelized<T> {\n\t// sanity\n\tif (!isObject(model)) throw new TypeError('Expecting class instance argument');\n\n\tconst isFn = (v) => typeof v === 'function';\n\n\t// defaults\n\tlet _CONFIG: ModelizeConfig<T> = {\n\t\t...({\n\t\t\tadditionalProperties: false,\n\t\t\tschema: null,\n\t\t\tvalidator: null,\n\t\t} as ModelizeConfig<T>),\n\t};\n\n\tlet _schemaCompiledValidate;\n\tconst _updateConfig = (config: Partial<ModelizeConfig<T>>) => {\n\t\t_CONFIG = { ..._CONFIG, ...config };\n\t\t// if schema was provided, compile validator now (the compilation for the same schema\n\t\t// is cached internally at ajv level, so no worry here)\n\t\tif (_CONFIG.schema) {\n\t\t\t_schemaCompiledValidate = ajv.compile(_CONFIG.schema);\n\t\t} else {\n\t\t\t_schemaCompiledValidate = null;\n\t\t}\n\t};\n\n\t// set now\n\t_updateConfig({\n\t\t// support for special case getter `__config` at model level\n\t\t...((model as any).__config || {}),\n\t\t// and via param\n\t\t...(config || {}),\n\t});\n\n\t// pub/sub with helper pause flag for \"construct\" time\n\tconst _pubsub = createPubSub();\n\tlet _doPublishChange = false;\n\n\t// collection of dirty (changed) keys\n\tconst _dirty = new Set<keyof T>();\n\n\t// helper flag to pause/resume validation\n\tlet _doValidate = true;\n\n\t//\n\tconst _validateSchema = (assert: boolean = true) => {\n\t\tif (!_schemaCompiledValidate) {\n\t\t\tthrow new Error('Unknown error... schema validator not available');\n\t\t}\n\t\tconst valid = _schemaCompiledValidate(model);\n\t\tif (valid) return true;\n\t\tif (assert) {\n\t\t\tthrow new ModelizeValidationError(\n\t\t\t\t_validateErrorsToString(_schemaCompiledValidate.errors)\n\t\t\t);\n\t\t}\n\t\treturn false;\n\t};\n\n\t//\n\tconst _validateOnlyIfValidatorOrSchema = (model: T) => {\n\t\tif (!_doValidate) return true;\n\t\tif (isFn(_CONFIG.validator)) {\n\t\t\treturn _CONFIG.validator(model, _CONFIG.schema, true);\n\t\t} else if (_CONFIG.schema) {\n\t\t\treturn _validateSchema(true);\n\t\t}\n\t};\n\n\t//\n\tconst set = (target: T, prop, value, receiver: T) => {\n\t\t_assertNonCollidingPropName(prop);\n\t\tif (_CONFIG.additionalProperties || Reflect.has(target, prop)) {\n\t\t\tconst old = Reflect.get(target, prop, receiver);\n\t\t\tconst success = Reflect.set(target, prop, value, receiver);\n\t\t\tif (success && value !== old) {\n\t\t\t\ttry {\n\t\t\t\t\t_validateOnlyIfValidatorOrSchema(target);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// undo... (this is kind of ugly)\n\t\t\t\t\tReflect.set(target, prop, old, receiver);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\t_dirty.add(prop);\n\t\t\t\t_doPublishChange &&\n\t\t\t\t\t_pubsub.publish('change', {\n\t\t\t\t\t\tmodel: target,\n\t\t\t\t\t\tchanged: { property: prop, old, new: value },\n\t\t\t\t\t});\n\t\t\t}\n\t\t\treturn success;\n\t\t}\n\t\treturn true;\n\t};\n\n\t// technically we could just mix it in via `Object.assign(model, methodsMixin)`... but those\n\t// methods would become enumerable (which is not desired) so we'll just else-if it in\n\t// the proxy trap below\n\tconst methodsMixin: ModelizedMethods<T> = {\n\t\t//\n\t\ttoJSON: (): Record<keyof T, any> =>\n\t\t\tObject.entries(model).reduce((m, [k, v]) => ({ ...m, [k]: v }), {} as T),\n\t\t//\n\t\t__hydrate: (data, forceClean = false) => {\n\t\t\tfor (let k in data || {}) set(model, k, data[k], model as any);\n\t\t\tforceClean && _dirty.clear();\n\t\t\treturn model as Modelized<T>;\n\t\t},\n\t\t//\n\t\t__isDirty: () => (_dirty.size ? Array.from(_dirty) : null),\n\t\t//\n\t\t__setClean: () => {\n\t\t\t_dirty.clear();\n\t\t\treturn model as Modelized<T>;\n\t\t},\n\t\t//\n\t\t__setDirty: (keys: (keyof T)[] = null) => {\n\t\t\tmethodsMixin.__setClean();\n\t\t\t(keys || Object.keys(model)).forEach((k) => k in model && _dirty.add(k));\n\t\t\treturn model as Modelized<T>;\n\t\t},\n\t\t//\n\t\t__getDirty: () => {\n\t\t\treturn (methodsMixin.__isDirty() || []).reduce(\n\t\t\t\t(m, k) => ({ ...m, [k]: model[k] }),\n\t\t\t\t{}\n\t\t\t);\n\t\t},\n\t\t//\n\t\t__validate: (assert: boolean = true) => {\n\t\t\tif (!_doValidate) return true;\n\t\t\t// do we have a custom validator fn?\n\t\t\tif (isFn(_CONFIG.validator)) {\n\t\t\t\treturn _CONFIG.validator(model as Modelized<T>, _CONFIG.schema, assert);\n\t\t\t} else if (_CONFIG.schema) {\n\t\t\t\treturn _validateSchema(assert);\n\t\t\t} else if (assert) {\n\t\t\t\tthrow new ModelizeUnableToValidate(\n\t\t\t\t\t'Unable to validate! Neither `validator` nor `schema` were provided.'\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t//\n\t\t__setSchema: (schema: any) => {\n\t\t\t_updateConfig({ schema: schema });\n\t\t\treturn model as Modelized<T>;\n\t\t},\n\t\t//\n\t\t__getSchema: () => _CONFIG.schema,\n\t\t//\n\t\t__setValidator: (validator: Validator<T>) => {\n\t\t\t_updateConfig({ validator: validator });\n\t\t\treturn model as Modelized<T>;\n\t\t},\n\t\t//\n\t\t__getValidator: () => _CONFIG.validator,\n\t\t//\n\t\t__setAllowAdditionalProps: (flag: boolean) => {\n\t\t\t_updateConfig({ additionalProperties: !!flag });\n\t\t\treturn model as Modelized<T>;\n\t\t},\n\t\t//\n\t\t__onChange: (cb) =>\n\t\t\t_pubsub.subscribe('change', ({ model, changed }) => cb(model, changed)),\n\t\t//\n\t\t__pauseValidate: () => {\n\t\t\t_doValidate = false;\n\t\t\treturn model as Modelized<T>;\n\t\t},\n\t\t//\n\t\t__resumeValidate: () => {\n\t\t\t_doValidate = true;\n\t\t\treturn model as Modelized<T>;\n\t\t},\n\t};\n\n\tconst _assertNonCollidingPropName = (name) => {\n\t\tif (methodsMixin[name]) {\n\t\t\tthrow new TypeError(`'${name}' is a reserved modelized method name!`);\n\t\t}\n\t};\n\n\t//\n\tObject.keys(model).forEach(_assertNonCollidingPropName);\n\n\t// final proxy\n\tconst modelized = new Proxy<T>(model, {\n\t\tget(target, prop, receiver) {\n\t\t\tconst value = Reflect.get(target, prop, receiver);\n\t\t\tif (isFn(value)) {\n\t\t\t\treturn (...args) => value.apply(target, args);\n\t\t\t} else if (methodsMixin[prop]) {\n\t\t\t\treturn (...args) => methodsMixin[prop].apply(target, args);\n\t\t\t} else {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t},\n\t\tset,\n\t}) as Modelized<T>;\n\n\t// if data are provided, hydrate now, set clean afterwards\n\tif (data) {\n\t\tmodelized.__hydrate(data);\n\t\t// makes no sense to be dirty at \"construct\" time (if not desired, simply `__setDirty`)\n\t\tmodelized.__setClean();\n\t}\n\n\t// from now on, publish changes\n\t_doPublishChange = true;\n\n\t//\n\treturn modelized;\n}\n","const isFn = (v) => typeof v === 'function';\n\nexport const createPubSub = () => {\n\tconst _subs = new Map();\n\tconst _subsFor = (event) => {\n\t\tif (!_subs.has(event)) _subs.set(event, new Set());\n\t\treturn _subs.get(event);\n\t};\n\n\tconst publish = (event, detail = {}) => {\n\t\t_subsFor(event).forEach((cb) => cb(detail));\n\t};\n\n\tconst subscribe = (event, cb) => {\n\t\tif (!isFn(cb)) throw new Error(`Expecting callback function`);\n\t\t_subsFor(event).add(cb);\n\t\treturn () => _subsFor(event).delete(cb);\n\t};\n\n\tconst subscribeOnce = (event, cb) => {\n\t\tconst unsub = subscribe(event, (data) => {\n\t\t\tcb(data);\n\t\t\tunsub();\n\t\t});\n\t\treturn unsub;\n\t};\n\n\tconst unsubscribeAll = (event) => _subs.delete(event);\n\n\treturn { publish, subscribe, subscribeOnce, unsubscribeAll };\n};\n"],"names":["isObject","ModelizeUnableToValidate","_Error","apply","this","arguments","_inheritsLoose","_wrapNativeSuper","Error","ModelizeValidationError","ajv","Ajv","strict","validateFormats","modelize","model","data","config","Object","prototype","toString","call","TypeError","_schemaCompiledValidate","isFn","v","_CONFIG","_extends","additionalProperties","schema","validator","_updateConfig","compile","__config","_subs","_subsFor","_pubsub","Map","event","has","set","Set","get","publish","detail","forEach","cb","subscribe","add","subscribeOnce","unsub","unsubscribeAll","_doPublishChange","_dirty","_doValidate","_validateSchema","assert","errors","reduce","memo","e","push","schemaPath","message","JSON","stringify","params","join","target","prop","value","receiver","_assertNonCollidingPropName","Reflect","old","success","_validateOnlyIfValidatorOrSchema","changed","property","new","methodsMixin","toJSON","entries","m","k","_extends2","__hydrate","forceClean","clear","__isDirty","size","Array","from","__setClean","__setDirty","keys","__getDirty","_extends3","__validate","__setSchema","__getSchema","__setValidator","__getValidator","__setAllowAdditionalProps","flag","__onChange","_ref2","__pauseValidate","__resumeValidate","name","modelized","slice"],"mappings":"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"}